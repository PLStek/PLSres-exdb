::exercise parcours-arbre
::title Parcours d'un arbre binaire
::tags algorithme arbre récursivité
::courses LO21.arbres
::source PL$tek
::question difficulty=3
	::text
		Écrivez l'algorithme permettant de parcourir un arbre binaire en **profondeur d'abord**, c'est-à-dire qu'on va d'abord descendre au plus profond puis remonter pour passer aux nœuds suivants.
		Le contenu de l'arbre et ce que vous en faites est à votre discrétion, par exemple vous pouvez vouloir afficher chaque élément d'un arbre contenant des nombres.

		{!svg: info/algo/exercises/depth-first.svg}
	::hint 1
		On rappelle qu'un arbre est une structure récursive, donc chaque nœud peut être considéré comme un sous-arbre à part entière
	::hint 2
		Ça implique donc une fonction récursive
	::hint 1
		Pensez bien à comment vous gérez vos conditions d'arrêt. Un nœud peut avoir 2 fils, un seul fils à gauche ou à droite, ou aucun fils
	::answer
		En gros, il suffit de parcourir les nœuds récursivement. Il y a plusieurs approches concernant les conditions d'arrêt, ça dépend de comment votre arbre est implémenté.
		Généralement, on va dire que *pas de fils* est dénoté par une valeur indéfinie ou nulle.
		Par exemple, si on veut la somme de tous les nœuds de l'arbre :

		```
		somme_nœuds_profondeur(nœud : nœud d'arbre):
			indéfini -> 0
			sinon -> valeur(nœud) + somme_nœuds_profondeur(gauche(nœud)) + somme_nœuds_profondeur(droite(nœud))
		```

		Dans une conception plus impérative :

		```
		parcours_profondeur(nœud : nœud d'arbre):
			Si `nœud` est défini:
				faire_qqch(valeur(nœud))
				parcours_profondeur(gauche(nœud))
				parcours_profondeur(droite(nœud))
		```
::question difficulty=1
	::text
		Adapter cet algorithme pour qu'il fonctionne sur n'importe quel arbre (on suppose qu'un nœud garde une liste de ses nœuds fils)
	::answer
		```
		parcours_profondeur(nœud : nœud d'arbre):
			Si `nœud` est défini:
				faire_qqch(valeur(nœud))
				Pour chaque `fils` de `nœud`:
					parcours_profondeur(fils)```
::question difficulty=4
	::text
		Écrire l'algorithme permettant de parcourir l'arbre en *largeur d'abord*, c'est-à-dire parcourir tous les enfants de la racine, puis les enfants de ces derniers, et ainsi de suite.

		{!svg: info/algo/exercises/breadth-first.svg}
	::hint 1
		Réfléchissez à l'approche qu'il faut avoir. On veut faire d'abord la racine, puis passer sur chacun de ses nœuds fils, puis sur les enfants de chaque nœud fils, et ainsi de suite
	::hint 1
		Autrement dit, on cherche à faire tous ces nœuds à la suite
	::hint 3
		On aura donc besoin d'une file, donc une approche itérative
	::hint 2
		Sur laquelle on enfile les nœuds qu'on croise pour les gérer plus tard
	::answer
		En gros, on commence par la racine, et à chaque nœud qu'on passe on enfile ses nœuds fils.

		```
		parcours_largeur(racine : arbre):
			Soit `file` une file vide pour contenir des nœuds
			Soit `nœud` un nœud d'arbre

			file.enfiler(racine)
			Tant que la `file` n'est pas vide:
				nœud := file.défiler()
				faire_qqch(nœud)
				Pour chaque `fils` de `nœud`:
					file.enfiler(fils)```
