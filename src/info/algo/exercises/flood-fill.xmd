::exercise flood-fill
::title Outil pot de peinture
::tags algorithme récursivité
::todo Test unitaire
::courses LO21.récursivité
::source PL$tek
::question difficulty=4
	::text
		On cherche à implémenter l'algorithme dit *flood-fill* (« remplissage par inondation »).
		Cet algorithme permet de remplir une zone délimitée d'un tableau multi-dimensions — c'est notamment utilisé pour l'outil pot de peinture de tous les logiciels d'édition d'image. Le principe est le suivant :

		- On a une image sous forme d'un tableau en deux dimensions, et un point de départ (le pixel sur lequel l'utilisateur clique). Pour ne pas compliquer inutilement la chose, on peut considérer que chaque pixel est un seul entier (image en noir et blanc)
		- L'idée est de regarder si les pixels autour du pixel en cours sont de la même couleur, et de poursuivre dans toutes les directions qui sont encore de la couleur à remplacer.

		Écrire l'algorithme de remplissage en pseudo-code ou dans le langage de votre choix.
	::hint 1
		Commencez bien par identifier les infos à donner à chaque appel, et au cas terminal
	::hint 3
		Le cas terminal est quand on atteint un pixel d'une couleur différente
	::hint 3
		Le cas général revient à appeler récursivement sur chaque pixel adjacent si la couleur du pixel est celle à remplacer.
	::answer
		Exemple en C :

		```c
		void floodFill(int image[LARGEUR][HAUTEUR], int x, int y, int remplacement) {
			int couleur = image[x][y];   // Couleur à remplacer
			image[x][y] = remplacement;  // Qu'on remplace de suite
			// Cas terminal plus ou moins implicite : quand aucun pixel adjacent n'a la couleur à remplacer
			// Cas général, on appelle récursivement sur chaque pixel adjacent de la bonne couleur
			if (x-1 >= 0 && image[x-1][y] == couleur)
				floodFill(image, x-1, y, remplacement);
			if (x+1 < LARGEUR && image[x+1][y] == couleur)
				floodFill(image, x+1, y, remplacement);
			if (y-1 >= 0 && image[x][y-1] == couleur)
				floodFill(image, x, y-1, remplacement);
			if (y+1 < HAUTEUR && image[x][y+1] == couleur)
				floodFill(image, x, y+1, remplacement);
		}```

		Exemple en Python :

		```python
		def floodFill_récursion(image, x, y, remplacé, remplacement):
			# Cas terminal : quand le pixel n'est pas de la bonne couleur ou est en dehors de l'image, on ne fait rien
			if 0 <= x < image.width and 0 <= y < image.height and image[x, y] == remplacé:
				# Cas général : on remplace le pixel en cours et on appelle récursivement sur les pixels adjacents
				image[x, y] = remplacement
				floodFill_récursion(image, x-1, y, remplacé, remplacement)
				floodFill_récursion(image, x+1, y, remplacé, remplacement)
				floodFill_récursion(image, x, y-1, remplacé, remplacement)
				floodFill_récursion(image, x, y+1, remplacé, remplacement)

		def floodFill(image, x, y, remplacement):
			floodFill_récursion(image, x, y, image[x, y], remplacement)
		```

::question difficulty=2
	::text
		Identifier les différences entre les deux implémentations, et trouver les différences et les raisons des choix de conception.
	::answer
		- Dans la version Python, on a une fonction récursive et un *wrapper* qui prépare les paramètres pour éviter la redondance dans ses propres paramètres (on a besoin de la couleur à remplacer, mais ce serait redondant que le code appelant la donne). On fait tous les appels récursifs directement, et on laisse la fonction appelée récursivement détecter le cas terminal
		- Dans la version C, ça se fait en une simple fonction, qui n'appelle récursivement que quand c'est pertinent.

		Ici, la version C est plus optimisée (ça ne fait que les appels récursifs strictement nécessaires, donc moins d'appels à exécuter et moins d'encombrement de la pile d'appels). Par contre, c'est une conception plus impérative (ça ne serait pas possible dans un langage fonctionnel par exemple), et c'est moins clair (le cas terminal est implicite, et ça part du principe que c'est bien appelé comme il faut sans pouvoir le vérifier strictement)

		La version Python fera des appels récursifs « inutiles », mais d'un point de vue conception et lisibilité c'est nettement plus propre. C'est ce genre de conception qui sera valide dans un langage déclaratif ou fonctionnel. Quand on conçoit ou documente un algorithme récursif on préfère passer par là.

::question difficulty=4
	::text
		Comme les images peuvent être grandes (la zone à remplir peut faire plusieurs millions de pixels), cet algorithme peut vite dépasser la taille de la pile. On préfère donc l'implémenter de façon itérative.

		Implémentez l'algorithme de façon itérative.
	::hint 1
		Il n'y a pas de version simple, il faudra convertir « manuellement ». Pour ça, il y aura besoin de créer une pile explicite.
	::hint 2
		L'idée est de mettre les arguments qui changent sur la pile pour simuler un appel récursif, et de les dépiler quand vous simulez l'appel de la fonction
	::hint 3
		Les seuls arguments qui changent à chaque appel récursif sont les coordonnées (x, y), donc il y a juste ça à mettre sur la pile
	::answer
		Conversion de la version pure récursive :

		```python
		from collections import deque

		def floodFill(image, x_initial, y_initial, remplacement):
			remplacé = image[x_initial, y_initial]
			pile = deque()  # On gère nous même la pile au lieu de laisser ça à la pile d'appels
			pile.append((x_initial, y_initial))
			while len(pile) > 0:
				x, y = pile.pop()  # « Exécution de la fonction » : On dépile les arguments
				# Pratiquement un copié-collé du corps de la fonction
				if 0 <= x < image.width and 0 <= y < image.height and image[x, y] == remplacé:
					image[x, y] = remplacement
					pile.append((x-1, y))  # « Appel récursif » : on empile les arguments
					pile.append((x+1, y))
					pile.append((x, y-1))
					pile.append((x, y+1))```

		Conversion de la version « optimisée » (en itératif ça optimise un peu moins mais un peu quand même) :

		```python
		from collections import deque

		def floodFill(image, x_initial, y_initial, remplacement):
			assert 0 <= x_initial < image.width
			assert 0 <= y_initial < image.height

			remplacé = image[x_initial, y_initial]
			pile = deque()
			pile.append((x_initial, y_initial))
			while len(pile) > 0:
				x, y = pile.pop()
				image[x, y] = remplacement
				if x-1 >= 0 and image[x-1, y] == remplacé:
					pile.append((x-1, y))
				if x+1 < image.width and image[x+1, y] == remplacé:
					pile.append((x+1, y))
				if y-1 >= 0 and image[x, y+1] == remplacé:
					pile.append((x, y-1))
				if y+1 < image.height and image[x, y+1] == remplacé:
					pile.append((x, y+1))```
